<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Javascript_Mysql_attack相关资讯</title>
    <link href="/2022/08/02/Javascript_Mysql_attack%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/08/02/Javascript_Mysql_attack%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、编程环境和基础"><a href="#一、编程环境和基础" class="headerlink" title="一、编程环境和基础"></a>一、编程环境和基础</h1><h3 id="cookie和session的区别是什么？"><a href="#cookie和session的区别是什么？" class="headerlink" title="cookie和session的区别是什么？"></a><strong>cookie和session的区别是什么？</strong></h3><p>1、<strong>cookie不是很安全</strong>，别人可以分析你存放在本地的cookie进行欺骗，<strong>考虑到安全性最好使用session</strong><br>2、session 在一定时间内是保存在服务器上的不过当访问越来越多时会比较占用服务器端性能资源 考虑到减轻资源性能方面我们最好用cookie<br>3、当一个<strong>cookie保存数据</strong>时有限的一般不超过4kb， 很多浏览器都限制站点<strong>最多保存20个cookie</strong> 而session 保存在服务器端 没有数据量的限制 可以保存更复杂的类型<br>4、二者的生命周期有明显的区别，<strong>cookie的生命周期是累计的而session是间隔的</strong>。</p><h3 id="get和post的方法有什么区别？"><a href="#get和post的方法有什么区别？" class="headerlink" title="get和post的方法有什么区别？"></a><strong>get和post的方法有什么区别？</strong></h3><p>1、二者<strong>参数位置</strong>get在url里，post在请求体中<br>2、get能被浏览器所<strong>缓存</strong>而post不能被缓存<br>3、get<strong>参数长度</strong>受限最大2048个字符而post不受限<br>4、 get因为放在url里<strong>安全</strong>较差而post的请求参数放在body里安全性线对较好<br>5、get请求可以通过浏览器直接<strong>访问</strong>支持刷新和后退而post请求不能被浏览器访问，刷新后数据需要重新传送。</p><h3 id="什么是http和https"><a href="#什么是http和https" class="headerlink" title="什么是http和https"></a><strong>什么是http和https</strong></h3><p>1.http协议传输的数据都是未加密的明文的因此使用http协议加密传输，隐私的信息是非常不安全的，为了保证这些隐私信息的加密安全就诞生了https协议<br>2.<strong>https是由ssl+http协议构建的</strong> 可以进行加密传输 身份证的网络协议要比http协议更加安全 https协议主要有两个作用：建立信息安全通过，用来保证数据传输的安全性，第二呢就是确定网站的真实性</p><h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a><strong>http和https的区别</strong></h3><p>1、http不要证书而https需要证书申请，需要一定的费用成本<br>2、http下的信息是明文传输的而<strong>https协议</strong>是由ssl+http协议构建的可进行加密传输身份认证网络协议<strong>可以防止网络传输内容被窃取篡改</strong><br>3、<strong>http和https</strong>使用的是完全不同的链接方式所以他们的端口也不一样 <strong>前者是80端口后者是443端口</strong></p><h3 id="AJAX的优势是什么"><a href="#AJAX的优势是什么" class="headerlink" title="AJAX的优势是什么"></a><strong>AJAX的优势是什么</strong></h3><p><strong>ajax</strong>是异步传输技术，可以通过<strong>javascript</strong>实现，也可以通过<strong>JQuery</strong>框架实现，实现局部刷新，减轻了服务器的压力，也提高了用户体验。</p><h3 id="Socket是什么？"><a href="#Socket是什么？" class="headerlink" title="Socket是什么？"></a><strong>Socket是什么？</strong></h3><p>  <strong>socket（套接字）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I&#x2F;O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。</strong></p><p>以供用户在设计网络应用程序时根据不同的要求来选择套接字有三种类型：<strong>流式套接字</strong>（SOCK-STREAM）、<strong>数据报套接字</strong>（SOCK-DGRAM）和<strong>原始套接字</strong>（SOCK-RAW）。</p><p>（1）<strong>流式套接字</strong>：它提供了一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。在TCP&#x2F;IP协议簇中，使用TCP协议来实现字节流的传输，当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</p><p>（2）<strong>数据报套接字</strong>：它提供了一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。在TCP&#x2F;IP协议簇中，使用UDP协议来实现数据报套接字。在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</p><p>（3）<strong>原始套接字</strong>：该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。</p><h3 id="Socket应用场景"><a href="#Socket应用场景" class="headerlink" title="Socket应用场景"></a>Socket应用场景</h3><p>1.浏览器进程与web服务器进程通信；<br>2.QQ进程与好友的QQ进程通信</p><h3 id="什么是高并发呢？"><a href="#什么是高并发呢？" class="headerlink" title="什么是高并发呢？"></a>什么是高并发呢？</h3><p><strong>通俗来讲，高并发是指在同一个时间点，有很多用户同时的访问同一 API 接口或者 Url 地址。它经常会发生在有大活跃用户量，用户高聚集的业务场景中。</strong></p><p>举个例子，高速路口，1秒钟来5部车，每秒通过5部车，高速路口运作正常。突然，这个路口1秒钟只能通过4部车，车流量仍然依旧，结果必定出现大塞车。（5条车道忽然变成4条车道的感觉）</p><p>同理，某一个秒内，20*500个可用连接进程都在满负荷工作中，却仍然有1万个新来请求，没有连接进程可用，系统陷入到异常状态也是预期之内。</p><p>某个抢购场景中，共有100个商品，最后一刻，已经消耗了99个商品，剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景）</p><h3 id="高并发网站的解决方案"><a href="#高并发网站的解决方案" class="headerlink" title="高并发网站的解决方案"></a>高并发网站的解决方案</h3><p>1、前端优化（CND加速、建立独立图片服务器）<br>2、服务端优化（页面静态化、并发处理[异步|多线程]、队列处理）<br>3、数据库优化（数据库缓存[Memcachaed|Redis]、读写分离、分库分表、分区）<br>4、Web服务器优化（负载均衡、反向代理）</p><h3 id="TCP-和UDP-的特点和区别"><a href="#TCP-和UDP-的特点和区别" class="headerlink" title="TCP 和UDP 的特点和区别"></a>TCP 和UDP 的特点和区别</h3><ol><li><strong>都是属于传输层协议</strong></li><li><strong>TCP</strong><ol><li>面向连接，所以只能一对一</li><li>面向字节流传输</li><li>数据可靠，不丢失</li><li>全双工通信</li></ol></li><li><strong>UDP</strong>（根据TCP特点反记）<ol><li>无连接，支持一对一，一对多，多对多</li><li>面向报文传输</li><li>首部开销小，数据不一定可靠但是速度更快</li></ol></li></ol><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><strong>一二三四五原则:（即一：消息系列；二：成功系列； 三：重定向系列；四：请求错误系列；五：服务器端错误系列。）</strong></p><p><strong>1、状态码分类</strong></p><ul><li>- 1xx：信息，服务器收到请求，需要请求者继续操作</li><li>- 2xx：成功</li><li>- 3xx：重定向</li><li>- 4xx：客户端错误</li><li>- 5xx：服务端错误</li></ul><p><strong>2、常用状态码</strong></p><ul><li>200：请求成功</li><li>301：永久重定向</li><li>302：临时移动,请求的内容已转移到新位置</li><li>400 bad request：客户端请求语法错误</li><li>401 unauthorized：客户端没有权限&#x2F;未授权</li><li>403 forbidden：服务器拒绝客户端请求</li><li>404 not found：客户端请求资源不存在</li><li>500 Internal Server Eerro：服务器内部错误</li><li>502 bad gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应</li><li>503 Service Unavailable 超载或系统维护</li><li>504 Gateway timeout：网关超时</li></ul><h3 id="如何理解MVC及有什么优点"><a href="#如何理解MVC及有什么优点" class="headerlink" title="如何理解MVC及有什么优点"></a>如何理解MVC及有什么优点</h3><p><strong>MVC是一个框架模式，它强制性的使应用程序输入、处理和输出分开</strong><br>M:代表就是具体的模型(model)主要作用就是与数据库进行数据交互<br>V：代表就是具体的视图（view）主要作用就是与用户进行数据交互<br>C：代表就是具体的控制器（controller）主要作用代表了处理具体的业务逻辑</p><p><strong>优点</strong>有以下：</p><p>①可以实现代码的重用性，避免产生代码冗余；</p><p>②M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式</p><h3 id="ThinkPHP如何防止SQL注入"><a href="#ThinkPHP如何防止SQL注入" class="headerlink" title="ThinkPHP如何防止SQL注入"></a>ThinkPHP如何防止SQL注入</h3><p>　　（1）查询条件尽量使用数组方式，这是更为安全的方式；</p><p>　　（2）如果不得已必须使用字符串查询条件，使用预处理机制；</p><p>　　（3）开启数据字段类型验证，可以对数值数据类型做强制转换；（3.1版本开始已经强制进行字段类型验证了）</p><p>　　（4）使用自动验证和自动完成机制进行针对应用的自定义过滤；</p><p>　　（5）使用字段类型检查、自动验证和自动完成机制等避免恶意数据的输入。</p><h1 id="二、PHP-相关"><a href="#二、PHP-相关" class="headerlink" title="二、PHP 相关"></a>二、PHP 相关</h1><h3 id="文件图片问题"><a href="#文件图片问题" class="headerlink" title="文件图片问题"></a>文件图片问题</h3><h4 id="FILES-是什么意思？"><a href="#FILES-是什么意思？" class="headerlink" title="$ _FILES 是什么意思？"></a><code>$ _FILES</code> 是什么意思？</h4><p><code>$_FILES</code> 是一个包含通过 HTTP POST 方式上传到当前脚本的项目的数组</p><h4 id="FILES-39-userfile-39-39-name-39-和-FILES-39-userfile-39-39-tmp-name-39-有什么区别"><a href="#FILES-39-userfile-39-39-name-39-和-FILES-39-userfile-39-39-tmp-name-39-有什么区别" class="headerlink" title="$ _FILES [&#39;userfile&#39;] [&#39;name&#39; ] 和 $ _FILES [&#39;userfile&#39;] [&#39;tmp_name&#39;] 有什么区别"></a><code>$ _FILES [&#39;userfile&#39;] [&#39;name&#39; ]</code> 和 <code>$ _FILES [&#39;userfile&#39;] [&#39;tmp_name&#39;]</code> 有什么区别</h4><p><code>$ _FILES [&#39;userfile&#39;] [&#39;name&#39;]</code> 表示客户端文件的原始名称，</p><p><code>$_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;]</code> 表示服务器上存储的文件的临时文件名。</p><h4 id="上传文件出问题时，如何获取错误信息"><a href="#上传文件出问题时，如何获取错误信息" class="headerlink" title="上传文件出问题时，如何获取错误信息"></a>上传文件出问题时，如何获取错误信息</h4><p><code>$_FILES[&#39;userfile&#39;][&#39;error&#39;]</code> 包括了与上传文件有关的错误代码。</p><h4 id="如何更改要上传的文件大小的最大值"><a href="#如何更改要上传的文件大小的最大值" class="headerlink" title="如何更改要上传的文件大小的最大值"></a>如何更改要上传的文件大小的最大值</h4><p>可通过更改 <code>php.ini</code> 中的 <code>upload_max_filesize</code> 来更改要上传的文件的最大大小。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="PHP-是什么"><a href="#PHP-是什么" class="headerlink" title="PHP 是什么"></a>PHP 是什么</h4><p>PHP 是一种基于脚本的 web 语言，开发者可以动态的创建网页。</p><h4 id="PHP-的全称"><a href="#PHP-的全称" class="headerlink" title="PHP 的全称"></a>PHP 的全称</h4><p>Hypertext Preprocessor（超文本预处理器）</p><h4 id="PHP-是否支持多重继承"><a href="#PHP-是否支持多重继承" class="headerlink" title="PHP 是否支持多重继承"></a>PHP 是否支持多重继承</h4><p>PHP 只支持单继承。PHP 的类使用关键字 <code>extends</code> 继承另一个类</p><h4 id="使用-final-修饰的类和方法代表什么意思"><a href="#使用-final-修饰的类和方法代表什么意思" class="headerlink" title="使用 final 修饰的类和方法代表什么意思"></a>使用 <code>final</code> 修饰的类和方法代表什么意思</h4><p><code>final</code> 是在 PHP5 版本引入的，它修饰的类不允许被继承，它修饰的方法不允许被重写。</p><h4 id="PHP-和-HTML-是如何交互的"><a href="#PHP-和-HTML-是如何交互的" class="headerlink" title="PHP 和 HTML 是如何交互的"></a>PHP 和 HTML 是如何交互的</h4><p>可以通过 PHP 脚本生成 HTML，还可以将信息从 HTML 传递到 PHP。</p><h4 id="PHP-和-Javascript-是如何交互的"><a href="#PHP-和-Javascript-是如何交互的" class="headerlink" title="PHP 和 Javascript 是如何交互的"></a>PHP 和 Javascript 是如何交互的</h4><p>PHP 和 Javascript <strong>无法直接进行</strong>交互，因为 PHP 是一种服务器端语言，而 Javascript 是一种浏览器语言。但是，我们可以交换变量，因为 PHP 可以生成将由浏览器执行的 Javascript 代码，并且可以通过 URL 将特定的变量传递回 PHP。</p><h4 id="获取图片属性（size-width-和-height）的函数是什么"><a href="#获取图片属性（size-width-和-height）的函数是什么" class="headerlink" title="获取图片属性（size, width, 和 height）的函数是什么"></a>获取图片属性（size, width, 和 height）的函数是什么</h4><p>获取图片大小 size：getimagesize ()；获取图片宽度 width：imagesx ()；获取图片高度 height：imagesy ()。</p><h4 id="include-和-require-在执行失败的情况下有什么不同"><a href="#include-和-require-在执行失败的情况下有什么不同" class="headerlink" title="include() 和 require() 在执行失败的情况下有什么不同"></a>include() 和 require() 在执行失败的情况下有什么不同</h4><p><code>include()</code> 将会产生一个警告，不影响后续程序的执行。</p><p><code>require()</code> 将会产生一个致命错误，后续程序停止执行。</p><h4 id="语句include和require的区别是什么-为避免多次包含同一文件，可用什么语句-代替它们"><a href="#语句include和require的区别是什么-为避免多次包含同一文件，可用什么语句-代替它们" class="headerlink" title="语句include和require的区别是什么?为避免多次包含同一文件，可用什么语句 代替它们?"></a>语句include和require的区别是什么?为避免多次包含同一文件，可用什么语句 代替它们?</h4><p>区别： </p><p>在失败的时候： </p><ul><li>include产生一个warning，而require产生直接产生错误中断 </li><li>require在运行前载入 </li><li>include在运行时载入</li></ul><p>代替语句： </p><ul><li>require_once</li><li>include_once</li></ul><h4 id="如何在-PHP-中强制转换类型？"><a href="#如何在-PHP-中强制转换类型？" class="headerlink" title="如何在 PHP 中强制转换类型？"></a>如何在 PHP 中强制转换类型？</h4><p>输出类型的名称必须在要强制转换的变量前的括号中指定，如下所示：</p><ul><li>(int), (integer) - 强制转换为整型</li><li>(bool), (boolean) - 强制转换为布尔值</li><li>(float), (double), (real) - 强制转换为浮点型</li><li>(string) - 强制转换为字符串</li><li>(array) - 强制转换为数组</li><li>(object) - 强制转换为对象</li></ul><h4 id="条件语句何时以-endif-结尾？"><a href="#条件语句何时以-endif-结尾？" class="headerlink" title="条件语句何时以 endif 结尾？"></a>条件语句何时以 endif 结尾？</h4><p>当最初的 if 后面跟着：然后是没有大括号的代码块时。</p><h4 id="SERVER-是什么意思？"><a href="#SERVER-是什么意思？" class="headerlink" title="$ _SERVER 是什么意思？"></a><code>$ _SERVER</code> 是什么意思？</h4><p><code>$_SERVER</code> 是一个包含 Web 服务器创建信息的数组，包括了路径，头部和脚本位置等。</p><h3 id="双引号和单引号的区别"><a href="#双引号和单引号的区别" class="headerlink" title="双引号和单引号的区别"></a>双引号和单引号的区别</h3><p>双引号解释变量，单引号不解释变量<br>双引号里插入单引号，其中单引号里如果有变量的话，变量解释<br>双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用{}将变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误<br>双引号解释转义字符，单引号不解释转义字符，但是解释’\和\<br>能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断）</p><h3 id="isset-和-empty-区别"><a href="#isset-和-empty-区别" class="headerlink" title="isset() 和 empty() 区别"></a><strong>isset() 和 empty() 区别</strong></h3><ol><li>isset判断变量是否存在，可以传入多个变量，若其中一个变量不存在则返回假；</li><li>empty判断变量是否为空为假，只可传一个变量，如果为空为假则返回真</li></ol><h3 id="什么是面向对象？主要特征是什么？"><a href="#什么是面向对象？主要特征是什么？" class="headerlink" title="什么是面向对象？主要特征是什么？"></a>什么是面向对象？主要特征是什么？</h3><ul><li>面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。</li><li>主要特征：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。如果是4个方面则加上：抽象。</li></ul><p><strong>封装：</strong></p><p>封装是保证软件部件具有优良的模块性的基础,封装的目标就是要实现软件部件的高内聚,低耦合,防止程序相互依赖性而带来的变动影响.</p><p><strong>继承：</strong></p><p>在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。</p><p><strong>多态：</strong></p><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p><strong>抽象：</strong></p><p>抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。</p><h3 id="PHP遍历数组的6种方式"><a href="#PHP遍历数组的6种方式" class="headerlink" title="PHP遍历数组的6种方式"></a>PHP遍历数组的6种方式</h3><ul><li><p>foreach</p></li><li><p>array_map 是一个匿名函数 返回一个数组 可以同时处理多个数组</p><ul><li>&#96;&#96;&#96;php<br>例子：<br>$arr&#x3D;[1,2,3,4,5,6];<br>$arr&#x3D;array_map(funtion(&amp;$time){<br>return $item;<br>},$arr)<br>echo $arr<br>结果：1，2，3，4，5，6<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>- array_walk 以引用传递的形式遍历数组，没有放回值而且只能处理一个数组<br><br>  - ```php<br>    例子：<span class="hljs-variable">$arr</span>=[1,2,3,4,5,6];<br>    arrat_walk(<span class="hljs-variable">$arr</span>,funtion(&amp;<span class="hljs-variable">$item</span>)&#123;<br>    <span class="hljs-variable">$item</span>=<span class="hljs-variable">$item</span>;<br>    &#125;)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$arr</span><br>    结果：1，2，3，4，5<br></code></pre></td></tr></table></figure></li></ul></li><li><p>for</p></li><li><p>each —-<code>这个函数执行效率不行，已经在PHP7.2更新后被废弃了 </code></p></li><li><p>reset 准确的讲不止reset一个函数，需要组合多个内置函数，平常写代码用不上，根据业务要求才会用上reset</p><ul><li><pre><code class="php">例子：$arr=[1,2,3,4,5,6];rest($arr)while($value=current($arr))&#123;    $ar[$key($arr)]=value;    next($arr);&#125;echo $arr结果：1，2，3，4，5</code></pre></li></ul></li></ul><h3 id="底层实现是通过散列表（hash-table）-双向链表（解决hash冲突）"><a href="#底层实现是通过散列表（hash-table）-双向链表（解决hash冲突）" class="headerlink" title="底层实现是通过散列表（hash table） + 双向链表（解决hash冲突）"></a>底层实现是通过散列表（hash table） + 双向链表（解决hash冲突）</h3><ul><li>hashtable：将不同的关键字（key）通过映射函数计算得到散列值（Bucket-&gt;h） 从而直接索引到对应的Bucket</li><li>hash表保存当前循环的指针，所以foreach 比for更快</li><li>Bucket：保存数组元素的key和value，以及散列值h</li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li>散列函数和元素数组（Bucket）中间添加一层大小和存储元素数组相同的映射表。</li><li>用于存储元素在实际存储数组中的下标</li><li>元素按照映射表的先后顺序插入实际存储数组中</li><li>映射表只是原理上的思路，实际上并不会有实际的映射表，而是初始化的时候分配Bucket内存的同时，还会分配相同数量的 uint32_t 大小的空间，然后将 arData 偏移到存储元素数组的位置。</li></ul><h3 id="解决hash重复-php使用的链表法-："><a href="#解决hash重复-php使用的链表法-：" class="headerlink" title="解决hash重复(php使用的链表法)："></a>解决hash重复(php使用的链表法)：</h3><ul><li>链表法:不同关键字指向同一个单元时，使用链表保存关键字（遍历链表匹配key）</li><li>开放寻址法：当关键字指向已经存在数据的单元的时候，继续寻找其他单元，直到找到可用单元（占用其他单元位置，更容易出现hash冲突，性能下降）</li></ul><h3 id="Nginx-和-php-之间的通信"><a href="#Nginx-和-php-之间的通信" class="headerlink" title="Nginx 和 php 之间的通信"></a>Nginx 和 php 之间的通信</h3><p><strong>1、通信方式：</strong></p><p>1）tcp socket</p><ul><li>跨服务器，nginx和php不在一个机器时，只能用这个方式</li><li>面向连接的协议，更好的保证通信的正确性和完整性</li></ul><p>2）unix socket</p><ul><li>不需要网络协议栈、打包拆包等</li><li>减少tcp 开销，效率比tcp socket 更高</li><li>高并发时候不稳定，连接数次暴增产生大量的缓存，大数据包可能直接返回异常</li></ul><h3 id="请说明-PHP-中传值与传引用的区别。什么时候传值什么时候传引用？"><a href="#请说明-PHP-中传值与传引用的区别。什么时候传值什么时候传引用？" class="headerlink" title="请说明 PHP 中传值与传引用的区别。什么时候传值什么时候传引用？"></a>请说明 PHP 中传值与传引用的区别。什么时候传值什么时候传引用？</h3><p><strong>按值传递</strong>：函数范围内对值的任何改变在函数外部都会被忽略<br><strong>按引用传递</strong>：函数范围内对值的任何改变在函数外部也能反映出这些修改<br><strong>优缺点</strong>：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。按引用传递则不需要复制值，对于性能提高很有好处。</p><h3 id="在PHP中error-reporting这个函数有什么作用"><a href="#在PHP中error-reporting这个函数有什么作用" class="headerlink" title="在PHP中error_reporting这个函数有什么作用"></a>在PHP中error_reporting这个函数有什么作用</h3><p>设置PHP的报错级别并返回当前级别。</p><h3 id="在程序的开发中，如何提高程序的运行效率"><a href="#在程序的开发中，如何提高程序的运行效率" class="headerlink" title="在程序的开发中，如何提高程序的运行效率"></a>在程序的开发中，如何提高程序的运行效率</h3><p>1、优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询；<br>2、数据表中创建索引；<br>3、对程序中经常用到的数据生成缓存。</p><h3 id="对于大流量的网站-您采用什么样的方法来解决访问量问题"><a href="#对于大流量的网站-您采用什么样的方法来解决访问量问题" class="headerlink" title="对于大流量的网站,您采用什么样的方法来解决访问量问题?"></a>对于大流量的网站,您采用什么样的方法来解决访问量问题?</h3><p>1、有效使用缓存，增加缓存命中率<br>2、使用负载均衡<br>3、对静态文件使用cdn进行存储和加速<br>4、想方法减少数据库的使用<br>5、查看出现统计的瓶颈在哪里<br>6、反向代理</p><h3 id="foo-和-foo-之间有什么区别"><a href="#foo-和-foo-之间有什么区别" class="headerlink" title="foo()和@foo()之间有什么区别"></a>foo()和@foo()之间有什么区别</h3><p>@代表所有warning忽略</p><h3 id="简述php的垃圾收集机制"><a href="#简述php的垃圾收集机制" class="headerlink" title="简述php的垃圾收集机制"></a>简述php的垃圾收集机制</h3><p>php中的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为0时，就回收该变量容器。如果一个zval的refcount减1之后大于0，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理。</p><h3 id="如何实现PHP的安全最大化？怎样避免SQL注入漏洞和XSS跨站脚本攻击漏洞"><a href="#如何实现PHP的安全最大化？怎样避免SQL注入漏洞和XSS跨站脚本攻击漏洞" class="headerlink" title="如何实现PHP的安全最大化？怎样避免SQL注入漏洞和XSS跨站脚本攻击漏洞"></a>如何实现PHP的安全最大化？怎样避免SQL注入漏洞和XSS跨站脚本攻击漏洞</h3><p>基本原则：不对外界展示服务器或程序设计细节（屏蔽错误），不相信任何用户提交的数据（过滤用户提交）。</p><h3 id="echo、print-r、print、var-dump区别"><a href="#echo、print-r、print、var-dump区别" class="headerlink" title="echo、print_r、print、var_dump区别"></a>echo、print_r、print、var_dump区别</h3><p>echo：语句结构；<br>print：是函数，有返回值<br>print_r：能打印数组，对象<br>var_dump:能打印对象数组，并且带数据类型</p><h3 id="写出smarty模板的特点"><a href="#写出smarty模板的特点" class="headerlink" title="写出smarty模板的特点"></a>写出smarty模板的特点</h3><p>速度快，编译型，缓存技术，插件机制，强大的表现逻辑</p><h3 id="PHP如何实现页面跳转"><a href="#PHP如何实现页面跳转" class="headerlink" title="PHP如何实现页面跳转"></a>PHP如何实现页面跳转</h3><p>方法一：php函数跳转，缺点，header头之前不能有输出，跳转后的程序继续执行，可用exit中断执行后面的程序。<br>header(“Location:网址”);&#x2F;&#x2F;直接跳转<br>header(“refresh:3;url&#x3D;<a href="https://link.zhihu.com/?target=http://www.jsdaima.com">http://www.jsdaima.com</a>“);&#x2F;&#x2F;三秒后跳转<br>方法二：利用meta<br>echo””;</p><h3 id="如何把一个GB2312格式的字符串装换成UTF-8格式"><a href="#如何把一个GB2312格式的字符串装换成UTF-8格式" class="headerlink" title="如何把一个GB2312格式的字符串装换成UTF-8格式"></a>如何把一个GB2312格式的字符串装换成UTF-8格式</h3><p>iconv(‘GB2312’,’UTF-8’,’js代码（<a href="https://link.zhihu.com/?target=http://www.jsdaima.com">http://www.jsdaima.com</a>）是IT资源下载与IT技能学习平台。’);<br>?&gt;</p><h3 id="如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理"><a href="#如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理" class="headerlink" title="如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理"></a>如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理</h3><p>htmlspecialchars或者htmlentities</p><h3 id="简述-private、-protected、-public修饰符的访问权限"><a href="#简述-private、-protected、-public修饰符的访问权限" class="headerlink" title="简述 private、 protected、 public修饰符的访问权限"></a>简述 private、 protected、 public修饰符的访问权限</h3><p>private : 私有成员, 在类的内部才可以访问。<br>protected : 保护成员，该类内部和继承类中可以访问。<br>public : 公共成员，完全公开，没有访问限制。</p><h3 id="this和self、parent这三个关键词分别代表什么？在哪些场合下使用"><a href="#this和self、parent这三个关键词分别代表什么？在哪些场合下使用" class="headerlink" title="$this和self、parent这三个关键词分别代表什么？在哪些场合下使用"></a>$this和self、parent这三个关键词分别代表什么？在哪些场合下使用</h3><p>$this 当前对象·<br>self 当前类<br>parent 当前类的父类</p><p>$this在当前类中使用,使用-&gt;调用属性和方法<br>self也在当前类中使用，不过需要使用::调用<br>parent在类中使用</p><h3 id="常用的魔术方法有哪些？举例说明"><a href="#常用的魔术方法有哪些？举例说明" class="headerlink" title="常用的魔术方法有哪些？举例说明"></a>常用的魔术方法有哪些？举例说明</h3><p>php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。<br>__construct() 实例化类时自动调用。<br>__destruct() 类对象使用结束时自动调用。<br>__set() 在给未定义的属性赋值的时候调用。<br>__get() 调用未定义的属性时候调用。<br>__isset() 使用isset()或empty()函数时候会调用。<br>__unset() 使用unset()时候会调用。<br>__sleep() 使用serialize序列化时候调用。<br>__wakeup() 使用unserialize反序列化的时候调用。<br>__call() 调用一个不存在的方法的时候调用。<br>__callStatic()调用一个不存在的静态方法是调用。<br>__toString() 把对象转换成字符串的时候会调用。比如 echo。<br>__invoke() 当尝试把对象当方法调用时调用。<br>__set_state() 当使用var_export()函数时候调用。接受一个数组参数。<br>__clone() 当使用clone复制一个对象时候调用。</p><h1 id="三、数据库相关"><a href="#三、数据库相关" class="headerlink" title="三、数据库相关"></a>三、数据库相关</h1><h3 id="请写出数据类型-int-char-varchar-datetime-text-的意思；请问-varchar-和-char有什么区别"><a href="#请写出数据类型-int-char-varchar-datetime-text-的意思；请问-varchar-和-char有什么区别" class="headerlink" title="请写出数据类型(int char varchar datetime text)的意思；请问 varchar 和 char有什么区别"></a>请写出数据类型(int char varchar datetime text)的意思；请问 varchar 和 char有什么区别</h3><p>**Int ** 整数  <strong>char</strong>  定长字符  <strong>Varchar</strong>  变长字符  <strong>Datetime</strong>  日期时间型  <strong>Text</strong>  文本型</p><p> <strong>Varchar与char</strong>的区别:</p><ol><li><p><strong>char</strong>是固定长度的字符类型，分配多少空间，就占用多长空间。</p></li><li><p><strong>Varchar</strong>是可变长度的字符类型，内容有多大就占用多大的空间，能有效节省空间。</p></li></ol><p>   <strong>由于varchar类型是可变的，所以在数据长度改变的时，服务器要进行额外的操作，所以效率比char类 型低。</strong></p><h3 id="为什么SQL语句命中索引比不命中索引还要快"><a href="#为什么SQL语句命中索引比不命中索引还要快" class="headerlink" title="为什么SQL语句命中索引比不命中索引还要快"></a>为什么SQL语句命中索引比不命中索引还要快</h3><p>MYSQL InnoDB 索引为例</p><p><strong>虽然，使用索引可以减少磁盘IO次数，提高查询效率，但是，索引也不能建立太多，如果一个表中</strong></p><p><strong>所有字段的索引很大，也会导致性能的下降。</strong></p><h3 id="索引的作用？"><a href="#索引的作用？" class="headerlink" title="索引的作用？"></a>索引的作用？</h3><p> <strong>索引可以快速的检索我们想要的数据</strong></p><h3 id="在使用索引时要注意几个点？"><a href="#在使用索引时要注意几个点？" class="headerlink" title="在使用索引时要注意几个点？"></a>在使用索引时要注意几个点？</h3><p>（1）索引表中的每个字段都会<strong>降低</strong>写入性能</p><p>（2）建议使用表中的<strong>唯一值</strong>作为索引字段</p><p>（3）在关系型数据库中充当<strong>外键的字段</strong>必须<strong>建立索引</strong>（原因：因为他们可跨多个表进行复杂查询的时候提高性能）</p><p>（4）索引会<strong>占用</strong>磁盘空间，选择索引的字段要慎重</p><h3 id="表切分-分为几种"><a href="#表切分-分为几种" class="headerlink" title="表切分 分为几种"></a>表切分 分为几种</h3><p><strong>水平切分</strong>：把一章数据为千万级别的大表根据业务主键切分成多张小表，那么这些小表可能达到100张甚至1000张。</p><p><strong>垂直切分</strong>：就是将单表中的多个列按照业务逻辑把它关联性比较大的列放到在同一张表上去</p><h3 id="SQL的执行响应比较慢怎么办？何排查思路"><a href="#SQL的执行响应比较慢怎么办？何排查思路" class="headerlink" title="SQL的执行响应比较慢怎么办？何排查思路"></a>SQL的执行响应比较慢怎么办？何排查思路</h3><p> 有以下<strong>四个</strong>原因：</p><p>​    (1)没有索引或者SQL没有命中索引导致索引失效</p><p>​(2)单表数据量过多，导致查询瓶颈</p><p>​(3)网络原因或者机器本身负载过高</p><p>​(4)热点数据导致单点负载不均衡</p><p>针对<strong>以上</strong>方案的<strong>解决方法</strong>:</p><p>1、打开MYSQL的慢程序日志，收集一段时间的慢查询找出耗时最长的SQL语句进行分析 比如可以利用执行计划Explain的去查询SQL是否有命中索引 若没有命中索引 优化SQL语句保证SQL走索引执行 若没办法优化 在表上添加索引（在优化SQL或者添加索引的时候 需要符合最左匹配原则）</p><p>2、将后缀为0-100的表放在一个数据库实例中然后在将100-200的表放到另一个数据库实例中把1000张表分别放到了10个数据库实例中我们感觉业务逻辑的主键，把<strong>请求路由到不同的这个数据实例中去</strong>，让每个数据库实例承担对应的流量，这样均摊的流量就是比较小，从而达到性能提升的目的。</p><p>3、网络原因或者机器负载的情况可以进行读写分离 比如MYSQL支持一主多从的分布式部署，我们可以将<strong>主库</strong>只用来处理写数据的操作，而<strong>多个从库</strong>只用来处理读操作。在流量比较大的场景中，可以增加从库来提高数据库的负载能力，从而提升数据库的总体性能。</p><p>4、热点数据导致单点数据负载不均衡的情况，这样的情况下对数据本身的调整以外，还可以增加缓存，然后将查询比较频繁的热点数据放到缓存中去Redis ES 等等 来缓解数据库的压力提高数据库的响应速度</p><h3 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h3><p>第一每个列都不可以再拆分。</p><p>第二在第一的基础上，非主键列完全依赖于主键，而不能依赖于主键的一部分。</p><p>第三在第二的基础上 ，非主键列只依赖于主键，不依赖于其他非主键。</p><h3 id="MYSQL有关权限表都有几个（5个）"><a href="#MYSQL有关权限表都有几个（5个）" class="headerlink" title="MYSQL有关权限表都有几个（5个）"></a>MYSQL有关权限表都有几个（5个）</h3><p>1、<strong>user权限表</strong>：记录允许链接数据库的账号信息</p><p>2、<strong>db权限表</strong>：记录各个账户在数据库上的操作权限</p><p>3、<strong>table_priv权限表</strong>：记录数据表级的操作权限</p><p>4、<strong>columns_priv权限表</strong>：记录数据列级的操作权限。</p><p>5、<strong>procs_priv表</strong>，用于对存储过程和存储函数进行权限设置。</p><h3 id="什么是事务？及其特性？"><a href="#什么是事务？及其特性？" class="headerlink" title="什么是事务？及其特性？"></a>什么是事务？及其特性？</h3><p><strong>事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。</strong> </p><p><strong>事务特性：</strong> <strong>原子性、一致性、隔离性、持久性</strong>;</p><h3 id="SQL语句主要分为哪几类"><a href="#SQL语句主要分为哪几类" class="headerlink" title="SQL语句主要分为哪几类"></a>SQL语句主要分为哪几类</h3><p>SQL语句的五种分类分别是DQL、DML、DDL、TCL和DCL，下面对SQL语句的五种分类进行列举：</p><p><strong>1、数据库查询语言（DQL）</strong></p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE 子句组成的查询块，简称DQL，Data Query Language。代表关键字为select。</p><p><strong>2、数据库操作语言（DML）</strong></p><p>用户通过它可以实现对数据库的基本操作。简称DML，Data Manipulation Language。代表关键字为insert、delete 、update。</p><p><strong>3、数据库定义语言（DDL）</strong></p><p>数据定义语言DDL用来创建数据库中的各种对象，创建、删除、修改表的结构，比如表、视图、索引、同义词、聚簇等，简称DDL，Data Denifition Language。代表关键字为create、drop、alter。和DML相比，DML是修改数据库表中的数据，而 DDL 是修改数据中表的结构。</p><p><strong>4、事务控制语言（TCL）</strong></p><p>TCL经常被用于快速原型开发、脚本编程、GUI和测试等方面，简称：TCL，Trasactional Control Languag。代表关键字为commit、rollback。</p><p><strong>5、数据控制语言（DCL）</strong></p><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。简称：DCL，Data Control Language。代表关键字为grant、revoke。</p><p><strong>以上就是对SQL语句五种分类的简单介绍，这里针对零基础的初学者只涉及了简单的概念和代表关键字的知识，在了解了这些内容后，再学习更深入的知识（比如SQL优化），希望大家在以后的java培训课程中学习到更多使用和操作方面的技能。</strong></p><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p><strong>死锁是指两个或两个以上的进程在执行过程中,由于竞争资源或者由于彼此通信而造成的一种阻塞的现象,若无外力作用,它们都将无法推进下去</strong></p><p><strong>产生原因</strong>：1、系统资源不足；2、进程推进顺序非法。</p><p><strong>产生死锁的四个必要条件</strong>：</p><p>1**.互斥条件**：涉及的资源是非共享的。</p><p>2.<strong>不剥夺条件</strong>：进程所获得的资源在未使用完毕之前不能被其它进程强行夺走。</p><p>3.<strong>部分分配</strong>：进程每次申请它所需要的一部分资源，在等待新资源的同时继续占用已分配到的资源。</p><p>4.<strong>环路条件</strong>：存在着一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程请求。</p><h3 id="什么是脏读、幻读、不可重复读？"><a href="#什么是脏读、幻读、不可重复读？" class="headerlink" title="什么是脏读、幻读、不可重复读？"></a>什么是脏读、幻读、不可重复读？</h3><p><strong>脏读</strong>：某个事物更新了一份数据，另一个事务在此时读取了同一份数据，由于某些原因，进行RollBack（回滚）操作，导致后一个事务读取的数据不正确。</p><p><strong>幻读</strong>：说的是存不存在的问题：原来不存在的,现在存在了,则是幻读；在一个事务中两次查询数据，第二次查询到了第一次没有看到的数据</p><p><strong>不可重复读</strong>：说的是变没变化的问题：原来是A,现在却变为了B,则为不可重复读；在一个事务中两次查询数据不一致，可能两次数据查询过程中插入了一个事务更新原有的数据</p><h3 id="视图有哪些特点"><a href="#视图有哪些特点" class="headerlink" title="视图有哪些特点"></a>视图有哪些特点</h3><p>（1） 简单性（2） 安全性（3）逻辑数据独立性(指局部逻辑数据结构)</p><h3 id="MYSQL常用的备份工具有哪些"><a href="#MYSQL常用的备份工具有哪些" class="headerlink" title="MYSQL常用的备份工具有哪些"></a>MYSQL常用的备份工具有哪些</h3><p>逻辑备份（mysqldump，mydumper）</p><p>物理备份（copy、xtrabackup）</p><h3 id="Mysql的存储引擎-myisam和innodb的区别"><a href="#Mysql的存储引擎-myisam和innodb的区别" class="headerlink" title="Mysql的存储引擎,myisam和innodb的区别"></a>Mysql的存储引擎,myisam和innodb的区别</h3><p>1、MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持；<br>2、MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快；<br>3、InnoDB不支持FULLTEXT类型的索引；<br>4、InnoDB中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可；<br>5、对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引；<br>6、DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除；<br>7、LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用；<br>8、MyISAM支持表锁，InnoDB支持行锁。</p><p>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。<br>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引(<strong>不完全正确</strong>)等。</p><h3 id="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？"><a href="#MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年-怎么优化？" class="headerlink" title="MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？"></a>MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h3><p>1、设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率；<br>2、选择合适的表字段数据类型和存储引擎，适当的添加索引；<br>3、mysql库主从读写分离；<br>4、找规律分表，减少单表中的数据量提高查询速度；<br>5、添加缓存机制，比如memcached，redis等；<br>6、不经常改动的页面，生成静态页面；<br>7、书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</p><h3 id="说说对SQL语句优化有哪些方法-选择几条"><a href="#说说对SQL语句优化有哪些方法-选择几条" class="headerlink" title="说说对SQL语句优化有哪些方法 (选择几条)"></a><strong>说说对SQL语句优化有哪些方法 (选择几条)</strong></h3><ol><li>Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录 的条件必须写在Where子句的末尾.HAVING最后。</li><li>用EXISTS替代IN、用NOT EXISTS替代NOT IN。</li><li>避免在索引列上使用计算 </li><li>避免在索引列上使用IS NULL和IS NOT NULL </li><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索 引。 </li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表 扫描 </li><li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫</li></ol><h1 id="四、攻击"><a href="#四、攻击" class="headerlink" title="四、攻击"></a>四、攻击</h1><h3 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h3><p><strong>XSS攻击又称为跨站脚本</strong>，XSS的重点不在于跨站点，而是在于脚本的执行。XSS是一种经常出现在Web应用程序中的计算机安全漏洞，是由于Web应用程序对用户的输入过滤不足而产生的，它允许恶意web用户将代码植入到提供给其它用户使用的页面中</p><h3 id="XSS攻击有哪几种类型"><a href="#XSS攻击有哪几种类型" class="headerlink" title="XSS攻击有哪几种类型"></a>XSS攻击有哪几种类型</h3><p>常见的XSS攻击有三种：<strong>反射型XSS攻击、DOM-based型XSS攻击、存储型XSS攻击</strong></p><p><strong>第一种：反射型XSS攻击</strong><br>反射型XSS攻击一般是攻击者通过特定手法，诱使用户去访问一个包含恶意代码的URL，当受害者点击这些<strong>专门设计的链接</strong>的时候，恶意代码会直接在受害者主机上的浏览器执行。此类XSS攻击通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端Cookies或进行钓鱼欺骗</p><p><strong>第二种：DOM-based型XSS攻击</strong><br>客户端的脚本程序可以<strong>动态地检查和修改页面内容</strong>，而不依赖于服务器端的数据。例如客户端从URL中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的JavaScript脚本，而这些脚本没有经过适当的过滤或者消毒，那么应用程序就可能受到DOM-based型XSS攻击。<br>需要特别注意以下的用户输入源document.URL、location.hash、location.search、document.referrer等。</p><p><strong>第三种：存储型XSS攻击</strong><br>攻击者事先将恶意代码<strong>上传或者储存到漏洞服务器</strong>中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此存储型XSS攻击的危害会更大。此类攻击一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p><h3 id="XSS攻击如何防范"><a href="#XSS攻击如何防范" class="headerlink" title="XSS攻击如何防范"></a>XSS攻击如何防范</h3><p>(1)<strong>基于特征的防御</strong>。XSS漏洞和著名的SQL注入漏洞一样，都是利用了Web页面的编写不完善，所以每一个漏洞所利用和针对的弱点都不尽相同。这就给XSS漏洞防御带来了困难，不可能以单一特征来概括所有XSS攻击。<br>传统的XSS防御在进行攻击鉴别时多采用特征匹配方式，主要是针对“javascript”这个关键字进行检索，但是这种鉴别不够灵活，凡是提交的信息中各有“javascript”时，就被硬性的被判定为XSS攻击。</p><p>(2)<strong>基于代码修改的防御</strong>。Web页面开发者在编写程序时往往会出现一些失误和漏洞，XSS攻击正是利用了失误和漏洞，因此一种比较理想的方法就是通过优化Web应用开发来减少漏洞，避免被攻击：1)用户向服务器上提交的信息要对URL和附带的的HTTP头、POST数据等进行查询，对不是规定格式、长度的内容进行过滤。2)实现Session标记（session tokens）、CAPTCHA系统或者HTTP引用头检查，以防功能被第三方网站所执行。3)确认接收的的内容被妥善的规范化，仅包含最小的、安全的Tag（没有javascript），去掉任何对远程内容的引用（尤其是样式表和javascript），使用HTTP 唯一的cookie。<br>当然，如上操作将会降低Web业务系统的可用性，用户仅能输入少量的制定字符，人与系统间的交互被降到极致，仅适用于信息发布型站点。并且考虑到很少有Web编码人员受过正规的安全培训，很难做到完全避免页面中的XSS漏洞。</p><p>(3)<strong>客户端分层防御策略</strong>。客户端跨站脚本攻击的分层防御策略是<strong>基于独立分配线程</strong>和<strong>分层防御策略</strong>的安全模型。它建立在客户端(浏览器)，这是它与其他模型最大的区别，之所以客户端安全性如此重要，客户端在接受服务器信息，选择性的执行相关内容。这样就可以使防御XSS攻击变得容易，该模型主要由<strong>三大部分</strong>组成：1)对每一个网页分配独立线程且分析资源消耗的“网页线程分析模块”；2)包含分层防御策略四个规则的用户输入分析模块；3)保存互联网上有关XSS恶意网站信息的XSS信息数据库。</p><h3 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack&#x2F;session riding，缩写为：CSRF&#x2F;XSRF。</p><h3 id="CSRF可以做什么？"><a href="#CSRF可以做什么？" class="headerlink" title="CSRF可以做什么？"></a>CSRF可以做什么？</h3><p>你这可以这么<strong>理解CSRF攻击</strong>：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账。。。。。。造成的问题包括：个人隐私泄露以及财产安全。</p><h3 id="CSRF与XSS攻击的区别？"><a href="#CSRF与XSS攻击的区别？" class="headerlink" title="CSRF与XSS攻击的区别？"></a>CSRF与XSS攻击的区别？</h3><p>（1）<strong>CSRF攻击的主要目的是</strong>让用户在不知情的情况下攻击自己已登录的一个系统，类似于钓鱼。<br>如用户当前已经登录了邮箱，或bbs（网络论坛），同时用户又在使用另外一个已经被你控制的站点，我们姑且叫它钓鱼网站。这个网站上面可能因为某个图片吸引你，你去点击一下，此时可能就会触发一个js的点击事件，构造一个bbs发帖的请求，去往你的bbs发帖，由于当前你的浏览器状态已经是登陆状态，。<br>所以session登陆cookie信息都会跟正常的请求一样，纯天然的利用当前的登陆状态，让用户在不知情的情况下，帮你发帖或干其他事情。<strong>预防措施</strong>，请求中加入随机数，让钓鱼网站无法正常伪造请求。<br>（2）<strong>XSS攻击的主要目的则是</strong>，想办法获取目标攻击网站的cookie，因为有了cookie相当于有了session，有了这些信息就可以在任意能接进互联网的pc登陆该网站，并以其他人的生份登陆，做一些破坏。预防措施，防止下发界面显示html标签，把《&#x2F;》等符号转义。</p><h3 id="什么是SQL注入攻击"><a href="#什么是SQL注入攻击" class="headerlink" title="什么是SQL注入攻击"></a>什么是SQL注入攻击</h3><p>1、SQL注入攻击是指，后台数据库操作时，如果拼接外部参数到SQL语句中，就可能导致欺骗服务器执行恶意的SQL语句，造成数据泄露、删库、页面篡改等严重后果。按变量类型分为：数字型、字符型；按HTTP提交方式分为：GET注入、POST注入、Cookie注入；按注入方式分为：报错注入、盲注（布尔盲注、时间盲注）、堆叠注入等等。</p><p>2、按变量类型分类：如SQL语句为select *from user where param&#x3D;1（数字型）、select *from user where param&#x3D;”abc”（字符型）。<br>按HTTP提交方式分类：通常GET注入变量在query string里、POST注入变量在body中、Cookie注入变量在Cookie中。<br>按注入方式分类：报错注入是指利用数据库的某些机制，故意制造错误条件，使得查询结果出现在错误信息中;盲注是指数据不能回显到前端页面，需要利用一些方法进行判断或者尝试。返回true或flase（布尔盲注），返回延时sleep()（时间盲注）;堆叠注入是指多条SQL语句一起执行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加快网页加载</title>
    <link href="/2022/07/24/%E5%8A%A0%E5%BF%AB%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
    <url>/2022/07/24/%E5%8A%A0%E5%BF%AB%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="加快网页加载"><a href="#加快网页加载" class="headerlink" title="加快网页加载"></a>加快网页加载</h2><ul><li>如果你的域名已备案，可以使用<a href="https://s.qiniu.com/N7beiu">七牛云 (opens new window)</a>、阿里云、腾讯云等大厂的 OSS 服务并绑定域名，将生成后的 public 目录下全部上传到 OSS，然后你不仅可以无服务器部署博客，加载速度也将无可比拟；</li><li>没有备案，也可以通过香港及海外地区的云，或者私有 CDN 等方式进行加速，推荐一份 <a href="https://www.julydate.com/post/60859300">CDN 使用指南 (opens new window)</a>。</li><li>如果图片是存在 source 目录中，建议搭配 <a href="https://github.com/chenzhutian/hexo-all-minifier">hexo-all-minifier (opens new window)</a>插件，可自动对图片进行压缩；</li><li>如果是存放在外部的图片，建议先使用 <a href="https://tinypng.com/">tinypng (opens new window)</a>进行压缩。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博客图床</title>
    <link href="/2022/07/24/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"/>
    <url>/2022/07/24/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="利用GitHub-JsDeliver-第三方CDN加速-创建属于自己的图床"><a href="#利用GitHub-JsDeliver-第三方CDN加速-创建属于自己的图床" class="headerlink" title="利用GitHub+JsDeliver[第三方CDN加速]创建属于自己的图床"></a>利用GitHub+JsDeliver[第三方CDN加速]创建属于自己的图床</h3><h4 id="1-图片上传"><a href="#1-图片上传" class="headerlink" title="1.图片上传"></a>1.图片上传</h4><p>#1.在GitHub上创建一个图片仓库【任意名字】一般用images命名</p><p>#2.将你的图片上传到你的仓库中</p><p><img src="D:\boke图片\微信图片_20220604165737.png"></p><p>这个是我创建的GitHub存放的图片仓库</p><h4 id="2-运用GitHub-JsDeliver加速图片"><a href="#2-运用GitHub-JsDeliver加速图片" class="headerlink" title="2.运用GitHub+JsDeliver加速图片"></a>2.运用GitHub+JsDeliver加速图片</h4><p>#注：这边建议图片能够压缩在1MB以内，博客打开时不会图片加载卡顿</p><p>我们进入一个图片后，获得它的url</p><p><img src="D:\boke图片\微信图片_20220604165752.png"></p><p>这个是我的某一张图片，它的url就是如下的地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/futrueandnow/</span>MyImage<span class="hljs-regexp">/raw/m</span>ain/wallhaven-<span class="hljs-number">7339</span>vv.jpg<br></code></pre></td></tr></table></figure><p><img src="D:\boke图片\微信图片_20220604170151.png"></p><p>其他照着写就🆗啦！！！</p><p>以上就是我们将我们的图片放入博客内的方法，当然也可以将图片存放在本地地址，这里就不一 一阐述啦！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>fluid主题搭建教程</title>
    <link href="/2022/07/24/fluid%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <url>/2022/07/24/fluid%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><h3 id="1-搭建博客前期准备"><a href="#1-搭建博客前期准备" class="headerlink" title="1.搭建博客前期准备"></a>1.搭建博客前期准备</h3><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>​#1.安装环境</p><p>​#2.安装hexo</p><p>​#3.初始化hexo</p><p>​#4.闯将GitHub仓库</p><p>​#5.创建SSH</p><p>​#6.hexo 部署到GitHub</p><p><strong>下文我们将从以上六点进行讲解，并将成功部署一个属于你自己的博客</strong></p><h4 id="1、-Hexo特点"><a href="#1、-Hexo特点" class="headerlink" title="1、 Hexo特点"></a>1、 Hexo特点</h4><p>Hexo 是一个简单、快速、强大的静态博客框架,出自台湾大学生 tommy351 之手。Hexo 更轻便更快捷，下面是其官网强调的四大特点：</p><ul><li>极速生成静态页面</li><li>一键部署博客</li><li>丰富的插件支持</li><li>支持 Markdown</li></ul><h3 id="二-下载安装环境"><a href="#二-下载安装环境" class="headerlink" title="二.下载安装环境"></a>二.下载安装环境</h3><h5 id="1-Node-js官网"><a href="#1-Node-js官网" class="headerlink" title="1.Node.js官网"></a>1.Node.js官网</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>nodejs.org<span class="hljs-regexp">/en/</span><br></code></pre></td></tr></table></figure><ul><li>安装完Node.js后可以用命令行终端查询是否有安装成功</li><li>使用 node -v 可以查询到当前安装的node版本</li><li>npm会在nodejs下载安装完之后自动安装，可在命令行自行查询</li></ul><h5 id="2-检查"><a href="#2-检查" class="headerlink" title="2.检查"></a>2.检查</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git -v  <br><span class="hljs-symbol">$</span> node -v<br><span class="hljs-symbol">$</span> npm -v<br><br># 更换下载源（提高下载速度）[主要原因：国外的镜像有延迟，我们使用国内的阿里镜像]<br><span class="hljs-symbol">$</span> npm config <span class="hljs-keyword">set</span> registry <span class="hljs-comment">https:</span>//<span class="hljs-comment">registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><h3 id="三、下载使用Hexo"><a href="#三、下载使用Hexo" class="headerlink" title="三、下载使用Hexo"></a>三、下载使用Hexo</h3><h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#1.创建一个文件，并在文件中使用git base here，在git终端中输入以下代码块</span><br>$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>输入 hexo -v 查看版本</p><p><strong>至此环境准备完成，开始使用 hexo 搭个人博客</strong></p><h4 id="2-初始化-Hexo"><a href="#2-初始化-Hexo" class="headerlink" title="2.初始化 Hexo"></a>2.初始化 Hexo</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ hexo init 【文件夹名】 <span class="hljs-regexp">//</span>输入自己想要的文件夹名字<br>$ cd 【文件夹名】<span class="hljs-regexp">//</span>进入创建好的文件夹<br>$ npm install<span class="hljs-regexp">//</span>npm包安装<br></code></pre></td></tr></table></figure><p>会生成很多文件夹，看不懂没关系，知道怎么配置就可以了。</p><p>接着输入以下指令进行本地启动查看</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ hexo clean    <span class="hljs-regexp">//</span>清理缓存<br>$ hexo g<span class="hljs-regexp">//</span>生成文件<br>$ hexo s<span class="hljs-regexp">//</span>进入博客<br></code></pre></td></tr></table></figure><p>这三个命令非常重要，接着，终端上会出现 <code>localhost:4000</code> 就可以看到生成的博客页面了</p><p>不用后可以<code>ctrl + c</code> 可以关掉服务</p><p>以上你就可以看到你的博客<strong>Hexo</strong> 页面啦！快去试试吧</p><p><strong>实践是检验真理的唯一标准</strong> !!!</p><h4 id="3-创建GitHub仓库"><a href="#3-创建GitHub仓库" class="headerlink" title="3.创建GitHub仓库"></a>3.创建GitHub仓库</h4><ol><li><p>首先，你先要有一个GitHub账户，去注册一个吧。</p></li><li><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库。</p></li><li><p>创建一个和你的GitHub名字相同的仓库，比如我的GitHub名字是futrueandnow所以我的仓库名字就是futrueandnow.github.io ,当然你之后也可以创建很多的其他的仓库，并不是说只有这么一个仓库哦，比如你的图床（放在博客中的）等等都是可以再创建一个仓库的，当然这是后话了。。。。</p></li></ol><h4 id="4-生成SSH添加GitHub仓库"><a href="#4-生成SSH添加GitHub仓库" class="headerlink" title="4.生成SSH添加GitHub仓库"></a>4.生成SSH添加GitHub仓库</h4><p>由于后续都是通过 SSH 进行仓库代码的快速部署，所以这一步很有必要，当然你如果一开始已经有过SSH绑定了，那么就可以不看这一步了，但是一定要清楚后面的步骤哦</p><p><strong>回到你的git bash中，输入以下</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;FutrueAndNow&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;26622XXXX@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>以上yourname 输入你的的GitHub用户名 ，youremail 输入你的GitHub中的绑定邮箱</p><p>可以用以下两条<strong>检查</strong>:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git config <span class="hljs-keyword">user</span>.name<br>$ git config <span class="hljs-keyword">user</span>.email<br></code></pre></td></tr></table></figure><p>然后创建SSH,输出以下的代码块,然后一路回车，遇到判断就判断</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>在 gitbash 中输入以下指令，查看是否 SSH 是否已绑定成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><h4 id="5-将-hexo-部署到-github"><a href="#5-将-hexo-部署到-github" class="headerlink" title="5.将 hexo 部署到 github"></a>5.将 hexo 部署到 github</h4><p>我们再配置文件中找到 _config.yml  翻到最后一页，将以下的代码替换</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/FutrueAndNow/futrueandnow.git</span><br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><p>以及你可以将url也改成你的GitHub上的域名</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">url: http:<span class="hljs-regexp">//</span>futrueandnow.github.io<br></code></pre></td></tr></table></figure><p>以上的两个futrueandnow都是我当时创建仓库的名字</p><p>然后进行部署</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<span class="hljs-comment">//清除无用缓存</span><br>hexo <span class="hljs-keyword">generate</span>  <span class="hljs-comment">//生成静态文章，可以用 hexo g 缩写</span><br>hexo deploy  <span class="hljs-comment">//部署文章，可以用hexo d缩写</span><br></code></pre></td></tr></table></figure><p>以上如果都配置完成那么你的博客就能上传到GitHub上啦！动手试试吧~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/24/hello-world/"/>
    <url>/2022/07/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
